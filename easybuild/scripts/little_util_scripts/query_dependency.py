#!/usr/bin/env python
from __future__ import print_function
import sys
import os
import argparse



#
# Prints reverse dependency table for given software. Can optionally 
# restrict to version, toolchain, and toolchain version.
# At the moment, requires an environment variable EBSW_DATABASE to be set 
# to the location of a database file generated by make_sw_database.py
#





######################################################################


def main():

    database_file = os.environ['EBSW_DATABASE']

    # get arguments
    parser = argparse.ArgumentParser(description="Prints a list of applications\
                                     that are dependent on the package given \
                                     as an argument. That is, what \
                                     applications will break if this package \
                                     is removed?")
    parser.add_argument("app_name", help="the name of the package to query")
    parser.add_argument("app_vers", nargs='?', help="Package version; if not \
                        given, query is done for all installed versions.",
                        default="ANY")
    parser.add_argument("tc_name", nargs='?', help="Toolchain name; if not \
                        given, query is done within all toolchains.",
                        default="ANY")
    parser.add_argument("tc_vers", nargs='?', help="Toolchain version; if not \
                         given, query is done within all version of named \
                         toolchain.", default="ANY")

    parser.add_argument("-f", "--dbfile",
                        help="Use local database file instead of default \
                              system file:  "+database_file)
    args = parser.parse_args()

    if(args.dbfile):
        database_file = args.dbfile

    dep0 = args.app_name
    dep0_vers = args.app_vers
    toolchain = args.tc_name
    toolchain_vers = args.tc_vers

    # some variables for formatting the output
    dep_level = 0
    top_tabs = ''

    # open the database file
    try:
        db_file = open(database_file, "r")
    except IOError:
        print("Cannot open database file. Check that the file")
        print("{0}".format(database_file))
        print("exits and is readable. If not, run toolchain_finder.py")
        sys.exit()

    # read all of the lines, then close it again
    lines = db_file.readlines()
    db_file.close()

    for line in lines:
        words = line.split()

        if (len(words) > 1):
            if(words[0] == "APP"):
                parent = words[1]
                parent_vers = words[2]
                tc = words[3]
                tc_vers = words[4]

                # we might have to check for multiple versions/ toolchains
                if(parent == dep0):

                    if ((parent_vers == dep0_vers) or (dep0_vers == "ANY")):
                        if ((tc == toolchain) or (toolchain == "ANY")):
                            if ((tc_vers == toolchain_vers) or
                               (toolchain_vers == "ANY")):

                                # this application satisfies,
                                # start a recursive query
                                print("--------------------------------------"
                                      "-----------------------")
                                print ("{0}: {1}{2} {3}\t{4}\t{5}".format(
                                       dep_level, top_tabs, dep0, parent_vers,
                                       tc, tc_vers))

                                find_parents(database_file, dep0, parent_vers,
                                             top_tabs, dep_level, tc,
                                             tc_vers)


######################################################################
def find_parents(database_file, dep, dep_vers, tabs, dep_level, test_tc,
                 test_tc_vers):

    # re-open database and look for any place where "dep" is listed
    # as a dependent
    # now toolchain and toolchain version of dependency must be specified

    # output formatting
    tabs = tabs+'\t'
    dep_level += 1

    db_file = open(database_file, "r")
    lines = db_file.readlines()
    db_file.close()

    for line in lines:
        words = line.split()

        if (len(words) > 1):
            if(words[0] == "APP"):
                parent = words[1]
                parent_vers = words[2]
                tc = words[3]
                tc_vers = words[4]

        if((words[0] == "DEP") and (words[1] == dep) and
           (words[2] == dep_vers)):
            # is this listing an acceptible version?

            if((tc == test_tc) and
               (tc_vers == test_tc_vers)):
                # is it in the right toolchain?

                print ("{0}: {1}{2} {3}\t{4}\t{5}".format(dep_level, tabs,
                                                          parent, parent_vers,
                                                          tc, tc_vers))

                find_parents(database_file, parent, parent_vers, tabs,
                             dep_level, tc, tc_vers)

if __name__ == "__main__":
    main()
