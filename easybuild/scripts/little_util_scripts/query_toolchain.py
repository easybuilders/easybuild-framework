#!/usr/bin/env python
from __future__ import print_function

import sys
import os
import argparse

#
# When given the name (or partial name) of an application this script lists
# the toolchain module that must be loaded.
# At the moment, requires an environment variable EBSW_DATABASE to be set 
# to the location of a database file generated by make_sw_database.py
#




if 'EBSW_DATABASE' in os.environ:
    database_file = os.environ['EBSW_DATABASE']
else:
    print ("Please define the environment variable EBSW_DATABASE "
           "as the full path to a database file generated by "
           "make_sw_database.py or use the -f DBFILE "
           "command line argument.")
    sys.exit()


# get arguments

parser = argparse.ArgumentParser(description="When given the name (or name "
                                 "and version) of a software package "
                                 "returns possible lmod command(s) to load "
                                 "the appropriate toolchain.")

parser.add_argument("app_name", help="the name of the package to query")
parser.add_argument("app_vers", nargs='?', help="Package version; if not "
                    "given, query is done for all installed versions.",
                    default="ANY")
parser.add_argument("-f", "--dbfile",
                    help="Use local database file instead of default \
                              system file:  "+database_file)
outputgroup = parser.add_mutually_exclusive_group()
outputgroup.add_argument("-T", "--tcformat",
                         help="Display toolchains in which the package is "
                         "available. Default", action="store_true",
                         default=True)
outputgroup.add_argument("-M", "--modloadformat",
                         help="Display commands needed to load appropriate "
                         "toolchane and software modules", action="store_true",
                         default=False)

args = parser.parse_args()

tc_format_flag = args.tcformat
modloadformat_flag = args.modloadformat
if modloadformat_flag:
    tc_format_flag = False

program = args.app_name
version = args.app_vers

argc = len(sys.argv)

if(args.dbfile):
    database_file = args.dbfile


try:
    db_file = open(database_file, "r")
except IOError:
    print("Cannot open database file. Check that the file")
    print("{0}".format(database_file))
    print("exits and is readable. If not, run toolchain_finder.py")
    sys.exit()

lines = db_file.readlines()
db_file.close()

results_found = False

print ("")
if tc_format_flag:
    print("Package/version\t\tToolchain/version")
    print("---------------\t\t-----------------")

for line in lines:

    words = line.split()
    if (words[0] == 'APP'):
        if (program.lower() in words[1].lower()):
            test_prog = words[1]
            test_vers = words[2]
            tc_module = words[3]
            tc_vers = words[4]

            results_found = True
            tcstring = ""
            if (version == "ANY") or (version == test_vers):
                if (tc_module == "dummy") and (tc_vers == "dummy"):
                    tcstring = "\t(No toolchain module needed)"
                    tcmodstring = ""
                else:
                    tcmodstring = "\t" + tc_module+"/" + tc_vers

                if tc_format_flag:
                    outstring = "\t\t" + tc_module+"/" + tc_vers+tcstring
                if modloadformat_flag:
                    outstring = "\t--->\t\tmodule load" + \
                        tcmodstring + "\t" + test_prog+"/" + test_vers+"\t" \
                        + tcstring

                print("{0}/{1}{2}".format(test_prog, test_vers,
                                          outstring))


if not results_found:
    print("No results found")
